// SPDX-License-Identifier: MIT
pragma solidity ^0.8.4;

import "@openzeppelin/contracts/access/Ownable.sol";
import "@chainlink/contracts/src/v0.8/VRFConsumerBase.sol";

contract CoinFlip is VRFConsumerBase, Ownable {
    //Chainlink variables
    // The amount of LINK to send with the request
    uint256 public fee;
    // ID of public key against which randomness is generated
    bytes32 public keyHash;

    // fee to be able to play the game
    uint256 public entryFee;

    // emitted when the flip is done
    event NewFlip(address player, uint256 result, bytes32 requestId);

    // mapping storing requestId with player address
    mapping(bytes32 => address) private requestHistory;

    /**
     * constructor inherits a VRFConsumerBase and initiates the values for keyHash, fee and gameStarted
     * @param vrfCoordinator address of VRFCoordinator contract
     * @param linkToken address of LINK token contract
     * @param vrfFee the amount of LINK to send with the request
     * @param vrfKeyHash ID of public key against which randomness is generated
     */
    constructor(
        address vrfCoordinator,
        address linkToken,
        bytes32 vrfKeyHash,
        uint256 vrfFee
    ) VRFConsumerBase(vrfCoordinator, linkToken) {
        keyHash = vrfKeyHash;
        fee = vrfFee;
    }

    /**
     * set entry fee for games
     */
    function setEntryFee(uint256 _amount) public onlyOwner {
        entryFee = _amount;
    }

    /**
     * entry point for players
     */
    function flipCoin() public payable {
        require(address(this).balance >= 2 ether, "Game balance empty");

        require(msg.value == entryFee, "Value sent not equal to entry fee");

        bytes32 requestId = getRandomValue();

        requestHistory[requestId] = msg.sender;
    }

    /**
     * flip coin is called to start the request for randomness
     */
    function getRandomValue() private returns (bytes32 requestId) {
        // LINK is an internal interface for Link token found within the VRFConsumerBase
        // Here we use the balanceOF method from that interface to make sure that our
        // contract has enough link so that we can request the VRFCoordinator for randomness
        require(LINK.balanceOf(address(this)) >= fee, "Not enough LINK");
        // Make a request to the VRF coordinator.
        // requestRandomness is a function within the VRFConsumerBase
        // it starts the process of randomness generation
        return requestRandomness(keyHash, fee);
    }

    /**
     * fulfillRandomness is called by VRFCoordinator when it receives a valid VRF proof.
     * This function is overrided to act upon the random number generated by Chainlink VRF.
     * @param requestId  this ID is unique for the request we sent to the VRF Coordinator
     * @param randomness this is a random unit256 generated and returned to us by the VRF Coordinator
     */
    function fulfillRandomness(bytes32 requestId, uint256 randomness)
        internal
        virtual
        override
    {
        // We want out winnerIndex to be in the length from 0 to players.length-1
        // For this we mod it with the player.length value
        uint256 result = randomness % 2;
        address player = requestHistory[requestId];

        if (result == 1) {
            payoutWinner(player);
        }

        emit NewFlip(player, result, requestId);
    }

    /**
     * payouts player if they get heads
     */
    function payoutWinner(address winner) private {
        uint256 reward = entryFee * 2;
        (bool success, ) = payable(winner).call{value: reward}("");
        require(success, "Transfer failed");
    }

    /**
     * get balance of contract
     */
    function getBalance() public view returns (uint256) {
        return address(this).balance;
    }

    /**
     * @notice Check link balance
     */
    function checkLinkBalance() external view returns (uint256) {
        return (LINK.balanceOf(address(this)));
    }

    /**
     * withdraw funds
     */
    function withdraw(uint256 _amount) public onlyOwner {
        require(_amount >= 1 ether, "Amount too small");
        require(_amount <= address(this).balance, "Insufficient balance");

        (bool success, ) = payable(msg.sender).call{value: _amount}("");
        require(success, "Transfer failed");
    }

    // Function to receive Ether. msg.data must be empty
    receive() external payable {}

    // Fallback function is called when msg.data is not empty
    fallback() external payable {}
}
